name: Image

on: [push, pull_request]

env:
  RUST_VERSION: "1.86.0"

jobs:
  docker:
    name: Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: Swatinem/rust-cache@v2
        with:
          key: image-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          load: true # required to allow for testing the image within this workflow
          tags: glim-test
          build-args: |
            RUST_VERSION=${{ env.RUST_VERSION }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Test image functionality
        run: |
          set -euxo pipefail

          # Generate health check token
          HEALTHCHECK_TOKEN=$(openssl rand -hex 64)
          echo "Generated health check token: ${HEALTHCHECK_TOKEN}"

          # Test server startup with debug logging
          docker run -d --name test-server \
            -p 8000:8000 \
            -e HOSTS=0.0.0.0:8000 \
            -e HEALTHCHECK_TOKEN=${HEALTHCHECK_TOKEN} \
            -e RUST_LOG=debug \
            -e LOG_LEVEL=debug \
            glim-test

          # Wait for server to start with retry logic
          for i in {1..30}; do
            echo "Attempt $i: Testing health endpoint..."

            # Test with verbose curl to see what's happening
            RESPONSE=$(curl -v -f -s -w "\nHTTP_CODE:%{http_code}\nTOTAL_TIME:%{time_total}\n" \
              -H "Authorization: Bearer ${HEALTHCHECK_TOKEN}" \
              http://0.0.0.0:8000/health 2>&1) || {
              echo "Curl failed with exit code $?"
              echo "Full curl response:"
              echo "$RESPONSE"

              # Check if it's a 401 (unauthorized)
              if echo "$RESPONSE" | grep -q "HTTP_CODE:401"; then
                echo "::error::Health endpoint returned 401 Unauthorized - authentication required"
                echo "=== Container logs ==="
                docker logs test-server
                echo "=== End container logs ==="
                exit 1
              fi

              # Check if it's a timeout
              if echo "$RESPONSE" | grep -q "timeout\|Connection refused"; then
                echo "Connection timeout or refused - server may not be ready yet"
              else
                echo "::error::Unexpected curl error"
                echo "=== Container logs ==="
                docker logs test-server
                echo "=== End container logs ==="
                exit 1
              fi
            }

            # Check if we got a successful response
            if echo "$RESPONSE" | grep -q "HTTP_CODE:200"; then
              echo "Server is ready after $i seconds"
              if [ $i -gt 8 ]; then
                echo "::warning::Server took longer than expected to start ($i seconds)"
              fi
              break
            fi

            if [ $i -eq 30 ]; then
              echo "::error::Server failed to start within 30 seconds"
              echo "=== Container logs ==="
              docker logs test-server
              echo "=== End container logs ==="
              exit 1
            fi
            sleep 1
          done

          # Test health endpoint with proper logging
          echo "Testing health endpoint..."
          if ! curl -v -f -H "Authorization: Bearer ${HEALTHCHECK_TOKEN}" http://0.0.0.0:8000/health; then
            echo "::error::Health endpoint test failed"
            echo "=== Container logs ==="
            docker logs test-server
            echo "=== End container logs ==="
            exit 1
          fi

          # Test main endpoint (should redirect)
          echo "Testing main endpoint..."
          if ! curl -v -f -I http://0.0.0.0:8000/; then
            echo "::error::Main endpoint test failed"
            echo "=== Container logs ==="
            docker logs test-server
            echo "=== End container logs ==="
            exit 1
          fi

          # Test image generation
          echo "Testing image generation..."
          if ! curl -v -f -o test-image.png -w "%{http_code}" http://0.0.0.0:8000/Xevion/Glim.png | grep -q "200"; then
            echo "::error::Image generation test failed"
            echo "=== Container logs ==="
            docker logs test-server
            echo "=== End container logs ==="
            exit 1
          fi

          # Verify it's a PNG file
          if ! file test-image.png | grep -q "PNG image data"; then
            echo "::error::Generated file is not a valid PNG image"
            exit 1
          fi

          # Clean up
          docker stop test-server
          docker rm test-server

      - name: Test image size
        run: |
          set -euo pipefail

          # Check Docker image size against limits
          # Usage: check_image_size <image_name> <max_size_str>
          # Returns: 0=OK, 1=too large, 2=warning (>90% of limit), -1=error
          check_image_size() {
            local image_name="$1"
            local max_size_str="$2"

            # Set max image size
            local MAX_IMAGE_SIZE=$(echo "$max_size_str" | numfmt --from=iec 2>/dev/null) || return -1
            echo "Max image size: ${MAX_IMAGE_SIZE} bytes"

            # Check that the image is reasonably sized
            local IMAGE_SIZE_RAW=$(docker images "$image_name" --format "{{.Size}}" 2>/dev/null) || return -1
            echo "Raw image size: ${IMAGE_SIZE_RAW}"

            # Convert size to MB (handle both decimal and integer sizes)
            local IMAGE_SIZE_BYTES=$(echo "${IMAGE_SIZE_RAW}" | sed 's/B$//' | numfmt --from=iec 2>/dev/null) || return -1
            echo "Image size in bytes: ${IMAGE_SIZE_BYTES}"

            # Fail if image is too large
            if [ "$IMAGE_SIZE_BYTES" -gt "$MAX_IMAGE_SIZE" ]; then
              return 1
            fi

            # Check if image is within 10% of the limit
            local WARNING_THRESHOLD=$((MAX_IMAGE_SIZE * 9 / 10))
            echo "Warning threshold: ${WARNING_THRESHOLD} bytes"
            if [ "$IMAGE_SIZE_BYTES" -ge "$WARNING_THRESHOLD" ]; then
              return 2
            fi

            return 0
          }

          # Check image size - capture return code, not output
          # Use || true to prevent set -e from failing on non-zero return codes
          check_image_size "glim-test" "100M" || RET_CODE=$?

          # Handle return code
          if [ $RET_CODE -eq 1 ]; then
            echo "::error::Image is too large"
            exit 1
          elif [ $RET_CODE -eq -1 ]; then
            echo "::warning::Image size check failed"
            exit 1
          elif [ $RET_CODE -eq 2 ]; then
            echo "::warning::Image is within 10% of the limit"
            exit 0
          fi
